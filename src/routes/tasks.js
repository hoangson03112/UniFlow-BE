import { Router } from "express";
import { z } from "zod";
import { Task } from "../models/Task.js";
import {
  authenticateFirebase,
  requireAuth,
} from "../middleware/firebaseAuth.js";

const router = Router();

// Apply Firebase auth to all routes
router.use(authenticateFirebase);
router.use(requireAuth);

// Validation schema phù hợp với frontend
const TaskBodySchema = z.object({
  title: z.string().min(1).max(200).trim(),
  weekdays: z.array(z.number().int().min(0).max(6)).min(1),
  timeRange: z.object({
    start: z
      .string()
      .regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format"),
    end: z
      .string()
      .regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format"),
  }),
  note: z.string().optional(),
  color: z
    .string()
    .regex(/^#[0-9A-F]{6}$/i)
    .optional(),
  isActive: z.boolean().default(true),
  isAutoGenerated: z.boolean().optional(),
  learningGoalId: z.string().optional(),
  isCompleted: z.boolean().optional(),
});

// GET /api/tasks - Lấy tất cả tasks của user
router.get("/", async (req, res) => {
  try {
    const { userId, firebaseUid } = req;

    const tasks = await Task.find({ userId });

    // Transform để phù hợp với frontend
    const formattedTasks = tasks.map((task) => {
      // Auto-complete past tasks before formatting
      task.autoCompleteIfPast();
      
      return {
        id: task._id.toString(),
        title: task.title,
        weekdays: task.weekdays,
        timeRange: task.timeRange,
        note: task.note,
        color: task.color,
        isActive: task.isActive,
        isAutoGenerated: task.isAutoGenerated || false,
        learningGoalId: task.learningGoalId?.toString(),
        isCompleted: task.effectiveIsCompleted, // Use virtual field
        isPastTask: task.isPastTask, // Add virtual field
        completedAt: task.completedAt,
        dailyCompletions: task.dailyCompletions || [],
        createdAt: task.createdAt,
        updatedAt: task.updatedAt,
      };
    });

    res.json({
      success: true,
      tasks: formattedTasks,
      total: formattedTasks.length,
    });
  } catch (error) {
    console.error("❌ Get tasks error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch tasks",
    });
  }
});

// GET /api/tasks/:id - Lấy task cụ thể
router.get("/:id", async (req, res) => {
  try {
    const { userId } = req;
    const { id } = req.params;

    const task = await Task.findOne({ _id: id, userId });

    if (!task) {
      return res.status(404).json({
        success: false,
        error: "Task not found",
      });
    }

    // Auto-complete past tasks before formatting
    task.autoCompleteIfPast();
    
    const formattedTask = {
      id: task._id.toString(),
      title: task.title,
      weekdays: task.weekdays,
      timeRange: task.timeRange,
      note: task.note,
      color: task.color,
      isActive: task.isActive,
      isAutoGenerated: task.isAutoGenerated || false,
      learningGoalId: task.learningGoalId?.toString(),
      isCompleted: task.effectiveIsCompleted, // Use virtual field
      isPastTask: task.isPastTask, // Add virtual field
      completedAt: task.completedAt,
      dailyCompletions: task.dailyCompletions || [],
      createdAt: task.createdAt,
      updatedAt: task.updatedAt,
    };

    res.json({
      success: true,
      task: formattedTask,
    });
  } catch (error) {
    console.error("❌ Get task error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch task",
    });
  }
});

// POST /api/tasks - Tạo task mới
router.post("/", async (req, res) => {
  try {
    const { userId } = req;
    const taskData = TaskBodySchema.parse(req.body);

    // Validate time range
    const startMinutes = timeToMinutes(taskData.timeRange.start);
    const endMinutes = timeToMinutes(taskData.timeRange.end);

    if (endMinutes <= startMinutes) {
      return res.status(400).json({
        success: false,
        error: "End time must be after start time",
      });
    }

    // Validate weekdays are not empty
    if (!taskData.weekdays || taskData.weekdays.length === 0) {
      return res.status(400).json({
        success: false,
        error: "At least one weekday must be selected",
      });
    }

    // Validate weekday values (0-6)
    const validWeekdays = [0, 1, 2, 3, 4, 5, 6];
    const invalidWeekdays = taskData.weekdays.filter(day => !validWeekdays.includes(day));
    if (invalidWeekdays.length > 0) {
      return res.status(400).json({
        success: false,
        error: "Invalid weekday values. Must be 0-6 (Sunday-Saturday)",
      });
    }

    // Validate title is not empty
    if (!taskData.title || taskData.title.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: "Task title cannot be empty",
      });
    }

    // Validate title length
    if (taskData.title.trim().length > 100) {
      return res.status(400).json({
        success: false,
        error: "Task title cannot exceed 100 characters",
      });
    }

    // Validate note length if provided
    if (taskData.note && taskData.note.length > 500) {
      return res.status(400).json({
        success: false,
        error: "Task note cannot exceed 500 characters",
      });
    }

    // Validate that manual tasks are not created for past days only
    if (!taskData.isAutoGenerated) {
      const today = new Date();
      const currentDay = today.getDay();
      const hasCurrentOrFutureDay = taskData.weekdays.some(day => day >= currentDay);
      
      if (!hasCurrentOrFutureDay) {
        return res.status(400).json({
          success: false,
          error: "Manual tasks cannot be created for past days only. Please include at least one current or future day.",
        });
      }
    }

    // Validate time is not in the past for today's tasks
    const today = new Date();
    const currentDay = today.getDay();
    const currentTime = today.getHours() * 60 + today.getMinutes();
    
    if (taskData.weekdays.includes(currentDay) && startMinutes < currentTime) {
      return res.status(400).json({
        success: false,
        error: "Cannot create tasks that start in the past for today.",
      });
    }

    const task = await Task.create({
      ...taskData,
      userId,
      isAutoGenerated: taskData.isAutoGenerated || false, // Set false for manual tasks
    });

    // Auto-complete past tasks before formatting
    task.autoCompleteIfPast();
    
    const formattedTask = {
      id: task._id.toString(),
      title: task.title,
      weekdays: task.weekdays,
      timeRange: task.timeRange,
      note: task.note,
      color: task.color,
      isActive: task.isActive,
      isAutoGenerated: task.isAutoGenerated || false,
      learningGoalId: task.learningGoalId?.toString(),
      isCompleted: task.effectiveIsCompleted, // Use virtual field
      isPastTask: task.isPastTask, // Add virtual field
      completedAt: task.completedAt,
      dailyCompletions: task.dailyCompletions || [],
      createdAt: task.createdAt,
      updatedAt: task.updatedAt,
    };

    res.status(201).json({
      success: true,
      task: formattedTask,
      message: "Task created successfully",
    });
  } catch (error) {
    console.error("❌ Create task error:", error);

    if (error.name === "ZodError") {
      return res.status(400).json({
        success: false,
        error: "Invalid input data",
        details: error.issues,
      });
    }

    res.status(500).json({
      success: false,
      error: "Failed to create task",
    });
  }
});

// PUT /api/tasks/:id - Cập nhật task
router.put("/:id", async (req, res) => {
  try {
    const { userId } = req;
    const { id } = req.params;
    const updates = TaskBodySchema.partial().parse(req.body);

    // Validate time range if provided
    if (updates.timeRange) {
      const startMinutes = timeToMinutes(updates.timeRange.start);
      const endMinutes = timeToMinutes(updates.timeRange.end);

      if (endMinutes <= startMinutes) {
        return res.status(400).json({
          success: false,
          error: "End time must be after start time",
        });
      }
    }

    // Get current task to check existing data
    const currentTask = await Task.findOne({ _id: id, userId });
    if (!currentTask) {
      return res.status(404).json({
        success: false,
        error: "Task not found",
      });
    }

    // Validate weekdays if provided
    if (updates.weekdays !== undefined) {
      if (!updates.weekdays || updates.weekdays.length === 0) {
        return res.status(400).json({
          success: false,
          error: "At least one weekday must be selected",
        });
      }

      const validWeekdays = [0, 1, 2, 3, 4, 5, 6];
      const invalidWeekdays = updates.weekdays.filter(day => !validWeekdays.includes(day));
      if (invalidWeekdays.length > 0) {
        return res.status(400).json({
          success: false,
          error: "Invalid weekday values. Must be 0-6 (Sunday-Saturday)",
        });
      }

      // Validate that manual tasks are not updated to past days only
      if (!currentTask.isAutoGenerated) {
        const today = new Date();
        const currentDay = today.getDay();
        const hasCurrentOrFutureDay = updates.weekdays.some(day => day >= currentDay);
        
        if (!hasCurrentOrFutureDay) {
          return res.status(400).json({
            success: false,
            error: "Manual tasks cannot be updated to past days only. Please include at least one current or future day.",
          });
        }
      }
    }

    // Validate title if provided
    if (updates.title !== undefined) {
      if (!updates.title || updates.title.trim().length === 0) {
        return res.status(400).json({
          success: false,
          error: "Task title cannot be empty",
        });
      }

      if (updates.title.trim().length > 100) {
        return res.status(400).json({
          success: false,
          error: "Task title cannot exceed 100 characters",
        });
      }
    }

    // Validate note if provided
    if (updates.note !== undefined && updates.note && updates.note.length > 500) {
      return res.status(400).json({
        success: false,
        error: "Task note cannot exceed 500 characters",
      });
    }

    // Validate time is not in the past for today's tasks
    const today = new Date();
    const currentDay = today.getDay();
    const currentTime = today.getHours() * 60 + today.getMinutes();
    
    const weekdaysToCheck = updates.weekdays || currentTask.weekdays;
    const timeRangeToCheck = updates.timeRange || currentTask.timeRange;
    
    if (weekdaysToCheck.includes(currentDay) && timeRangeToCheck) {
      const startMinutes = timeToMinutes(timeRangeToCheck.start);
      
      if (startMinutes < currentTime) {
        return res.status(400).json({
          success: false,
          error: "Cannot update tasks to start in the past for today.",
        });
      }
    }

    const task = await Task.findOneAndUpdate(
      { _id: id, userId },
      { $set: updates },
      { new: true, runValidators: true }
    );

    if (!task) {
      return res.status(404).json({
        success: false,
        error: "Task not found",
      });
    }

    // Auto-complete past tasks before formatting
    task.autoCompleteIfPast();
    
    const formattedTask = {
      id: task._id.toString(),
      title: task.title,
      weekdays: task.weekdays,
      timeRange: task.timeRange,
      note: task.note,
      color: task.color,
      isActive: task.isActive,
      isAutoGenerated: task.isAutoGenerated || false,
      learningGoalId: task.learningGoalId?.toString(),
      isCompleted: task.effectiveIsCompleted, // Use virtual field
      isPastTask: task.isPastTask, // Add virtual field
      completedAt: task.completedAt,
      dailyCompletions: task.dailyCompletions || [],
      createdAt: task.createdAt,
      updatedAt: task.updatedAt,
    };

    res.json({
      success: true,
      task: formattedTask,
      message: "Task updated successfully",
    });
  } catch (error) {
    console.error("❌ Update task error:", error);

    if (error.name === "ZodError") {
      return res.status(400).json({
        success: false,
        error: "Invalid input data",
        details: error.issues,
      });
    }

    res.status(500).json({
      success: false,
      error: "Failed to update task",
    });
  }
});

// DELETE /api/tasks/:id - Xóa task
router.delete("/:id", async (req, res) => {
  try {
    const { userId } = req;
    const { id } = req.params;

    const result = await Task.deleteOne({ _id: id, userId });

    if (result.deletedCount === 0) {
      return res.status(404).json({
        success: false,
        error: "Task not found",
      });
    }

    res.json({
      success: true,
      message: "Task deleted successfully",
    });
  } catch (error) {
    console.error("❌ Delete task error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to delete task",
    });
  }
});

// GET /api/tasks/week/:date - Lấy tasks cho tuần cụ thể
router.get("/week/:date", async (req, res) => {
  try {
    const { userId } = req;
    const { date } = req.params;

    const targetDate = new Date(date);
    if (isNaN(targetDate.getTime())) {
      return res.status(400).json({
        success: false,
        error: "Invalid date format",
      });
    }

    // Get all active tasks for user
    const tasks = await Task.find({
      userId,
      isActive: true,
    }).lean();

    // Group by day of week
    const weekSchedule = {};
    for (let i = 0; i < 7; i++) {
      weekSchedule[i] = tasks
        .filter((task) => task.weekdays.includes(i))
        .map((task) => ({
          id: task._id.toString(),
          title: task.title,
          weekdays: task.weekdays,
          timeRange: task.timeRange,
          note: task.note,
          color: task.color,
          isAutoGenerated: task.isAutoGenerated || false,
          learningGoalId: task.learningGoalId?.toString(),
          isCompleted: task.isCompleted || false,
          completedAt: task.completedAt,
          dailyCompletions: task.dailyCompletions || [],
        }))
        .sort(
          (a, b) =>
            timeToMinutes(a.timeRange.start) - timeToMinutes(b.timeRange.start)
        );
    }

    res.json({
      success: true,
      weekSchedule,
      date: targetDate.toISOString().split("T")[0],
    });
  } catch (error) {
    console.error("❌ Get week schedule error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch week schedule",
    });
  }
});

// PATCH /api/tasks/:id/toggle-completion - Toggle completion status
router.patch("/:id/toggle-completion", async (req, res) => {
  try {
    const { userId } = req;
    const { id } = req.params;
    const { date } = req.body; // Optional: specific date for daily completion

    const task = await Task.findOne({ _id: id, userId });

    if (!task) {
      return res.status(404).json({
        success: false,
        error: "Task not found",
      });
    }

    const today = date || new Date().toISOString().split("T")[0];
    
    if (task.isAutoGenerated) {
      // For auto-generated tasks, use daily completion tracking
      const existingCompletion = task.dailyCompletions.find(c => c.date === today);
      
      if (existingCompletion) {
        // Toggle existing completion
        existingCompletion.isCompleted = !existingCompletion.isCompleted;
        existingCompletion.completedAt = existingCompletion.isCompleted ? new Date() : null;
      } else {
        // Add new completion
        task.dailyCompletions.push({
          date: today,
          completedAt: new Date(),
          isCompleted: true
        });
      }
      
      // Update overall completion status
      task.isCompleted = task.dailyCompletions.some(c => c.isCompleted && c.date === today);
      task.completedAt = task.isCompleted ? new Date() : null;
    } else {
      // For manual tasks, simple toggle
      task.isCompleted = !task.isCompleted;
      task.completedAt = task.isCompleted ? new Date() : null;
    }

    await task.save();

    // Auto-complete past tasks before formatting
    task.autoCompleteIfPast();
    
    const formattedTask = {
      id: task._id.toString(),
      title: task.title,
      weekdays: task.weekdays,
      timeRange: task.timeRange,
      note: task.note,
      color: task.color,
      isActive: task.isActive,
      isAutoGenerated: task.isAutoGenerated || false,
      learningGoalId: task.learningGoalId?.toString(),
      isCompleted: task.effectiveIsCompleted, // Use virtual field
      isPastTask: task.isPastTask, // Add virtual field
      completedAt: task.completedAt,
      dailyCompletions: task.dailyCompletions || [],
      createdAt: task.createdAt,
      updatedAt: task.updatedAt,
    };

    res.json({
      success: true,
      task: formattedTask,
      message: `Task ${task.isCompleted ? 'completed' : 'uncompleted'} successfully`,
    });
  } catch (error) {
    console.error("❌ Toggle completion error:", error);
    res.status(500).json({
      success: false,
      error: "Failed to toggle completion status",
    });
  }
});

// Helper function
function timeToMinutes(timeString) {
  const [hours, minutes] = timeString.split(":").map(Number);
  return hours * 60 + minutes;
}

export default router;
